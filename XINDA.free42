00 { 1294-Byte Prgm }
// 4STK mode default, FUNC does not compile
// LBL A-J/a-e are local lettered (for HP 41ᴇxecute 15 options)
// Max label local 23
// Max register number so far 04 (fractions)
// Stats reserve registers 11 to 23 (do not alter)
// Temp working register 24 (if needed)
// Local VARS
// L last X
// R REGS
// S temporary local REGS
// T T
// U temporary local T
// X X
// Y Y
// Z Z

// ========= app menu ==========
// divide by related sections
01 LBL "APP"
// MENU keys GTO for menu change, XEQ for operation
02 "FRAC"
// fractions
03 KEY 1 GTO "FRAC"
04 "INTS"
// integer operations
05 KEY 2 XEQ "INTS"
06 "PDFS"
// beta and probability density functions (integration)
07 KEY 3 XEQ "PDFS"
08 ""
09 KEY 4 XEQ "name"
10 ""
11 KEY 5 XEQ "name"
12 "Σf(x)"
// summation application
13 KEY 6 XEQ "Σf(x)"
// UP
14 KEY 7 GTO "APP"
// DOWN
15 KEY 8 GTO "APP"
// EXIT
16 KEY 9 GTO "XITEND"
17 GTO "NTRMENU"

// ========= fraction menu ==========
18 LBL "FRAC"
// MENU keys GTO for menu change, XEQ for operation
19 "÷+→"
// store initial fraction as N/D for 4 operation postfix
20 KEY 1 XEQ 09
21 "÷++"
22 KEY 2 XEQ 10
23 "÷+-"
24 KEY 3 XEQ 11
25 "÷+×"
26 KEY 4 XEQ 12
27 "÷+÷"
28 KEY 5 XEQ 13
29 "→÷+"
// print fraction from N/D
30 KEY 6 XEQ 14
// UP
31 KEY 7 GTO "FRAC"
// DOWN
32 KEY 8 GTO "FRAC"
// EXIT
33 KEY 9 GTO "APP"
34 GTO "NTRMENU"

// ========= integers menu ==========
35 LBL "INTS"
// MENU keys GTO for menu change, XEQ for operation
36 "GCD"
// greatest common divisor
37 KEY 1 XEQ "GCD"
38 "LCM"
// least common multiple
39 KEY 2 XEQ "LCM"
40 ""
41 KEY 3 XEQ "name"
42 ""
43 KEY 4 XEQ "name"
44 ""
45 KEY 5 XEQ "name"
46 ""
47 KEY 6 XEQ "name"
// UP
48 KEY 7 GTO "INTS"
// DOWN
49 KEY 8 GTO "INTS"
// EXIT
50 KEY 9 GTO "APP"
51 GTO "NTRMENU"

// ========= PDFs menu ==========
52 LBL "PDFS"
// MENU keys GTO for menu change, XEQ for operation
53 "BETA"
54 KEY 1 XEQ "BETA"
55 ""
56 KEY 2 XEQ "name"
57 ""
58 KEY 3 XEQ "name"
59 ""
60 KEY 4 XEQ "name"
61 ""
62 KEY 5 XEQ "name"
63 ""
64 KEY 6 XEQ "name"
// UP
65 KEY 7 GTO "PDFS"
// DOWN
66 KEY 8 GTO "PDFS"
// EXIT
67 KEY 9 GTO "APP"
68 GTO "NTRMENU"

// ========= menu utilities ==========
// ========= show menus and wait ==========
69 LBL "NTRMENU"
70 MENU
71 STOP
72 GTO "APP"

// ========= clear menus and exit ==========
73 LBL "XITEND"
74 CLMENU
75 EXITALL
76 RTN

// ========= FRAC ==========
// ========= frac local processsing ==========
// don't use temporay REGS as persists
// display post operation uses all 4 levels
// L register is decimal representation
77 LBL 09
// store denominator
78 STO 00
79 R↓
80 X<>Y
81 ×
82 +
// store numerator
83 STO 01
84 RCL÷ 00
// makes decimal in X
85 GTO 16
86 LBL 10
87 XEQ 15
// add
// sub short cut
88 LBL 18
89 XEQ 19
// numerator addition
90 RCL 03
91 STO+ 01
92 R↓
93 GTO 16
94 LBL 11
95 XEQ 15
// sub
96 RCL 01
97 STO- 01
98 STO- 01
99 R↓
100 GTO 18
101 LBL 12
102 XEQ 15
// mul
// div short cut
103 LBL 17
104 RCL 02
105 STO× 00
106 R↓
107 RCL 03
108 STO× 01
109 R↓
110 GTO 16
111 LBL 13
112 XEQ 15
// div
113 RCL 00
114 STO 24
115 R↓
116 RCL 01
117 STO 00
118 R↓
119 RCL 24
120 STO 01
121 R↓
122 GTO 17
123 LBL 14
// to decimal in T, Z+Y/X
124 RCL 01
125 RCL÷ 00
126 ENTER
127 IP
128 ENTER
129 RCL× 00
130 RCL- 01
131 +/-
132 RCL 00
133 R↑
134 STO ST L
135 R↓
136 RTN
// clone and read new
137 LBL 15
138 RCL 00
139 STO 02
140 R↓
141 RCL 01
142 STO 03
143 R↓
144 GTO 09
// cancel GCD
145 LBL 16
146 RCL 01
// zero numerator?
147 X=0?
148 RTN
149 RCL 00
150 XEQ "GCD"
151 STO÷ 01
152 STO÷ 00
// display
153 XEQ 14
154 RTN
// normalize pair
155 LBL 19
156 RCL 00
157 ENTER
158 RCL 02
159 XEQ "LCM"
// store LCM as have stacked in Y denominator
160 STO 00
161 X<>Y
162 ÷
// grow base fraction numerator
163 STO× 01
164 RCL 00
165 RCL 02
166 ÷
// grow second fraction numerator
167 STO× 03
168 RTN

// ========= INTS ==========
// ========= GCD ==========
169 LBL "GCD"
// like hidden [FIND]?
170 "[GCD]"
// save a return
171 GTO "XINDA"
172 LBL "[GCD]"
173 MOD
174 LASTX
175 X<>Y
176 X≠0?
177 GTO "[GCD]"
178 +
179 XEQ "DRPXY"
180 GTO "XIT1"

// ========= LCM ==========
181 LBL "LCM"
// like hidden [FIND]?
182 "[LCM]"
183 GTO "XINDA"
184 LBL "[LCM]"
185 XEQ "GCD"
186 RCL "X"
187 X<>Y
188 ÷
189 RCL× "Y"
190 XEQ "DRPXY"
191 GTO "XIT1"

// ========= PDFS and special functions ==========
// ========= beta function ==========
192 LBL "BETA"
193 "[BETA]"
194 GTO "XINDA"
195 LBL "[BETA]"
196 RCL ST Y
197 GAMMA
198 RCL ST Y
199 GAMMA
200 ×
201 RCL ST Z
202 RCL ST Z
203 +
204 GAMMA
205 ÷
206 XEQ "DRPXY"
207 GTO "XIT1"

// ========= execute indirect alpha (entry point) ==========
// Use RCLT if you need the global T restored
// otherwise it's gone for evaluation
// easiest way of getting a "free" working register
208 LBL "XINDA"
// save stack
209 LSTO "X"
210 R↓
211 LSTO "Y"
212 R↓
213 LSTO "Z"
214 R↓
215 LSTO "T"
// make local temp context for local T
216 LSTO "U"
217 R↓
// save last X
218 LASTX
219 LSTO "L"
220 R↓
// save registers
221 RCL "REGS"
222 LSTO "R"
// local temp context for registers
223 LSTO "S"
224 R↓
// do indirect
225 ASTO ST T
// no need for XEQ
226 GTO IND ST T

// ========= exit points ==========
// return a number of items
// tail call GTO
// perform all the clean up FUNC style
// use DRPX to consume input stack datum
// so FUNC 11 is a DRPX XIT1 kinda XEQ
// ========= zero return datums ==========
227 LBL "XIT0"
228 XEQ 00
229 XEQ 04
230 RTN

// ========= one return datum ==========
231 LBL "XIT1"
232 XEQ 00
233 XEQ 03
234 GTO 05

// ========= two return datums ==========
235 LBL "XIT2"
236 XEQ 00
237 XEQ 02
238 GTO 06

// ========= three return datums ==========
239 LBL "XIT3"
240 XEQ 00
241 XEQ 01
242 GTO 07

// ========= four return datums ==========
243 LBL "XIT4"
244 XEQ "STOT"
245 XEQ 00
246 GTO "LRCLT"

// ========= exit stack repair ==========
247 LBL 04
248 RCL "T"
249 LBL 03
250 RCL "Z"
251 LBL 02
252 RCL "Y"
253 LBL 01
254 RCL "X"
255 RTN

// ========= rotary fixing ==========
256 LBL 05
257 R↓
258 LBL 06
259 R↓
260 LBL 07
261 R↓
262 RTN

// ========= T management ==========
// ========= repair global T ==========
263 LBL "RCLT"
264 RCL "T"
265 R↓
266 RTN

// ========= store local T (U) ==========
// needs a LSTO "U" in the outer context
// so that "U" remains local
267 LBL "STOT"
268 R↑
269 STO "U"
270 R↓
271 RTN

// ========= repair local T (U) ==========
272 LBL "LRCLT"
273 RCL "U"
274 R↓
275 RTN

// ========= restore registers and last X ==========
// restore registers called by XIT0-XIT4.
276 LBL 00
277 RCL "R"
278 STO "REGS"
279 R↓
// restore last X
280 RCL "L"
281 STO ST L
282 R↓
283 RTN

// ========= drop one return value ==========
// T->Z->Y->X->L
// local context
284 LBL "DRPX"
285 LSTO "U"
286 XEQ "STOT"
287 RCL "X"
288 STO "L"
289 R↓
290 RCL "Y"
291 STO "X"
292 R↓
293 RCL "Z"
294 STO "Y"
295 R↓
296 RCL "T"
297 STO "Z"
298 R↓
299 GTO "LRCLT"

// ========= drop two return values ==========
300 LBL "DRPXY"
301 XEQ "DRPX"
302 GTO "DRPX"

// ========= temporary register switching ==========
// imoprt local copy of registers to S
303 LBL "IMPRG"
304 XEQ "EXREG"
305 GTO "EXREG"

// this is it's own inverse, if used twice by the above S
// is initialized with a local copy of REGS
// use this to export registers from function
306 LBL "EXREG"
307 XEQ "STOT"
308 RCL "R"
309 STO "S"
310 R↓
311 RCL "REGS"
312 STO "R"
313 R↓
314 XEQ "LRCLT"
// ========= export registers from S ==========
315 LBL "EXPRG"
316 XEQ "STOT"
317 RCL "S"
318 STO "REGS"
319 R↓
320 GTO "LRCLT"

// ========= utility functions ==========
// ========= test shift was last key ==========
321 LBL "SFT?"
322 FS? 64
323 RTNYES
324 RTNNO

// ========= return errors ==========
// 0: None
// 1: Alpha Invalid
// 2: Out of Range
// 3: Divide 0
// 4: Invalid Type
// 5: Invalid Data
// 6: Nonexistant
// 7: Dimension Error
// 8: Too Few Args

// >> RTNERR IND ST T can be alpha chars
// ========= nested summation ==========
325 LBL "Σ(Σ)"
// "Σ(Σ)"
// ASTO 24
// RTNERR IND 24
// doesn't compile so nest implies exceeding
// dimension?
326 RTNERR 7

// ========= programatic summation template ==========
// a function to provide integration like summation
// as this is not built in but would be useful
// use PGMMENU
// MVAR "Σ"
// ..
// RCL- "Σ"
// RTN
// >>"Select Σf(x) Program"
// ""
// XEQ "PGMSUM"
// STO knowns
// STO "LLIM"
// STO "ULIM"
// >>"Set Vars; Select Σvar"
// ""
// XEQ "SUMATE"
// >>"VIEW "Σ""

// T: ??
// Z: ??
// Y: Last term evaluated
// X: Sum
327 LBL "Σf(x)"
328 PGMMENU
329 "Select Σf(x) Program"
330 PROMPT
331 STOP
// have alpha of program to execute
332 XEQ "PGMSUM"
333 VARMENU IND 24
334 "Set Vars; Select Σvar"
335 PROMPT
336 STOP
337 "LLIM"
338 KEY 1 XEQ 22
339 "ULIM"
340 KEY 2 XEQ 23
341 ""
342 KEY 3 GTO 20
343 ""
344 KEY 4 GTO 20
345 ""
346 KEY 5 GTO 20
347 "Σ"
// call SUMATE indirectly and VIEW "Σ"
348 KEY 6 XEQ 21
// UP
349 KEY 7 GTO 20
// DOWN
350 KEY 8 GTO 20
// EXIT
// needs R/S to redisplay APP menu
351 KEY 9 GTO "XITEND"
// local to store sum in
352 LSTO "Σ"
353 GTO "NTRMENU"
// call SUMATE and and VIEW
354 LBL 21

355 VIEW "Σ"
356 RTN
// LLIM
357 LBL 22

358 RTN
// ULIM
359 LBL 23

360 RTN
// save temp alpha prog
361 LBL "PGMSUM"
362 ASTO 24
363 RTN
// ??
364 LBL 08


// ========= programatic integration template ==========
// subtract the integral MVAR in integrals
// this makes setting it to zero integrates
// and using a program in solve then also works
// messages displayed as >> in integrate app
// MVAR "∫"
// ..
// RCL- "∫"
// RTN
// >>"Select ∫f(x) Program"
// PGMINT ""
// STO knowns
// STO "LLIM"
// STO "ULIM"
//? STO "ACC"
// >>"Set Vars; Select ∫var"
// INTEG ""
// >>"VIEW "∫""

// T: ??
// Z: ??
// Y: Uncertainty
// X: Integral


// ========= programatic solve template ==========
// PGMSLV ""
// STO knowns
// SOLVE ""

// T: Solve state (GTO IND ST T // plus offset?)
// = 0: Solved
// = 1: Sign reversal
// = 2: Extremum
// = 3: Bad guesses
// = 4: Function constant
// Z: f(X(t))
// Y: X(t-1)
// X: X(t)


