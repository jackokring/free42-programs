00 { 907-Byte Prgm }
// 4STK mode default, FUNC does not compile
// LBL A-J/a-e are local lettered
// Max label local 19
// Max register number so far 04
// Stats reserve registers 11 to 23
// Temp working register 24
// Local VARS
// L last X
// R REGS
// S temporary local REGS
// T T
// U temporary local T
// X X
// Y Y
// Z Z

// ========= app menu ==========
// divide by related sections
01 LBL "APP"
// MENU keys GTO for menu change, XEQ for operation
02 "FRAC"
// fractions
03 KEY 1 GTO "FRAC"
04 "INTS"
// integer operations
05 KEY 2 XEQ "INTS"
06 ""
07 KEY 3 XEQ "name"
08 ""
09 KEY 4 XEQ "name"
10 ""
11 KEY 5 XEQ "name"
12 ""
13 KEY 6 XEQ "name"
// UP
14 KEY 7 GTO "APP"
// DOWN
15 KEY 8 GTO "APP"
// EXIT
16 KEY 9 GTO "XITEND"
17 GTO "NTRMENU"

// ========= fraction menu ==========
18 LBL "FRAC"
// MENU keys GTO for menu change, XEQ for operation
19 "÷+→"
// store initial fraction as N/D for 4 operation postfix
20 KEY 1 XEQ 09
21 "÷++"
22 KEY 2 XEQ 10
23 "÷+-"
24 KEY 3 XEQ 11
25 "÷+×"
26 KEY 4 XEQ 12
27 "÷+÷"
28 KEY 5 XEQ 13
29 "→÷+"
// print fraction from N/D
30 KEY 6 XEQ 14
// UP
31 KEY 7 GTO "FRAC"
// DOWN
32 KEY 8 GTO "FRAC"
// EXIT
33 KEY 9 GTO "APP"
34 GTO "NTRMENU"

// ========= integers menu ==========
35 LBL "INTS"
// MENU keys GTO for menu change, XEQ for operation
36 "GCD"
// greatest common divisor
37 KEY 1 XEQ "GCD"
38 ""
39 KEY 2 XEQ "name"
40 ""
41 KEY 3 XEQ "name"
42 ""
43 KEY 4 XEQ "name"
44 ""
45 KEY 5 XEQ "name"
46 ""
47 KEY 6 XEQ "name"
// UP
48 KEY 7 GTO "INTS"
// DOWN
49 KEY 8 GTO "INTS"
// EXIT
50 KEY 9 GTO "APP"
51 GTO "NTRMENU"

// ========= menu utilities ==========
// ========= show menus and wait ==========
52 LBL "NTRMENU"
53 MENU
54 LBL 08
55 STOP
56 GTO 08

// ========= clear menus and exit ==========
57 LBL "XITEND"
58 CLMENU
59 EXITALL
60 RTN

// ========= FRAC ==========
// ========= frac local processsing ==========
// don't use temporay REGS as persists
// display post operation uses all 4 levels
// L register is decimal representation
61 LBL 09
// store denominator
62 STO 00
63 R↓
64 X<>Y
65 ×
66 +
// store numerator
67 STO 01
68 RCL÷ 00
// makes decimal in X
69 GTO 16
70 LBL 10
71 XEQ 15
// add
// sub short cut
72 LBL 18
73 XEQ 19
// numerator addition
74 RCL 03
75 STO+ 01
76 R↓
77 GTO 16
78 LBL 11
79 XEQ 15
// sub
80 RCL 01
81 STO- 01
82 STO- 01
83 R↓
84 GTO 18
85 LBL 12
86 XEQ 15
// mul
// div short cut
87 LBL 17
88 RCL 02
89 STO× 00
90 R↓
91 RCL 03
92 STO× 01
93 R↓
94 GTO 16
95 LBL 13
96 XEQ 15
// div
97 RCL 00
98 STO 24
99 R↓
100 RCL 01
101 STO 00
102 R↓
103 RCL 24
104 STO 01
105 R↓
106 GTO 17
107 LBL 14
// to decimal in T, Z+Y/X
108 RCL 01
109 RCL÷ 00
110 ENTER
111 IP
112 ENTER
113 RCL× 00
114 RCL- 01
115 +/-
116 RCL 00
117 R↑
118 STO ST L
119 R↓
120 RTN
// clone and read new
121 LBL 15
122 RCL 00
123 STO 02
124 R↓
125 RCL 01
126 STO 03
127 R↓
128 GTO 09
// cancel GCD
129 LBL 16
130 RCL 01
// zero numerator?
131 X=0?
132 RTN
133 RCL 00
134 XEQ "GCD"
135 STO÷ 01
136 STO÷ 00
// display
137 XEQ 14
138 RTN
// normalize pair
139 LBL 19
140 RCL 00
141 RCL 02
142 XEQ "GCD"
// temp
143 STO 24
144 RCL 00
145 RCL÷ 24
146 STO× 03
147 RCL 02
148 RCL÷ 24
149 ENTER
150 STO× 01
151 R↓
// and denominator
152 STO× 00
153 RTN

// ========= INTS ==========
// ========= GCD ==========
154 LBL "GCD"
// like hidden [FIND]?
155 "[GCD]"
// save a return
156 GTO "XINDA"
157 LBL "[GCD]"
158 MOD
159 LASTX
160 X<>Y
161 X≠0?
162 GTO "[GCD]"
163 +
164 XEQ "DRPXY"
165 GTO "XIT1"

// ========= execute indirect alpha (entry point) ==========
// Use RCLT if you need the global T restored
// otherwise it's gone for evaluation
// easiest way of getting a "free" working register
166 LBL "XINDA"
// save stack
167 LSTO "X"
168 R↓
169 LSTO "Y"
170 R↓
171 LSTO "Z"
172 R↓
173 LSTO "T"
// make local temp context for local T
174 LSTO "U"
175 R↓
// save last X
176 LASTX
177 LSTO "L"
178 R↓
// save registers
179 RCL "REGS"
180 LSTO "R"
// local temp context for registers
181 LSTO "S"
182 R↓
// do indirect
183 ASTO ST T
// no need for XEQ
184 GTO IND ST T

// ========= exit points ==========
// return a number of items
// tail call GTO
// perform all the clean up FUNC style
// use DRPX to consume input stack datum
// so FUNC 11 is a DRPX XIT1 kinda XEQ
// ========= zero return datums ==========
185 LBL "XIT0"
186 XEQ 00
187 XEQ 04
188 RTN

// ========= one return datum ==========
189 LBL "XIT1"
190 XEQ 00
191 XEQ 03
192 GTO 05

// ========= two return datums ==========
193 LBL "XIT2"
194 XEQ 00
195 XEQ 02
196 GTO 06

// ========= three return datums ==========
197 LBL "XIT3"
198 XEQ 00
199 XEQ 01
200 GTO 07

// ========= four return datums ==========
201 LBL "XIT4"
202 XEQ "STOT"
203 XEQ 00
204 GTO "LRCLT"

// ========= exit stack repair ==========
205 LBL 04
206 RCL "T"
207 LBL 03
208 RCL "Z"
209 LBL 02
210 RCL "Y"
211 LBL 01
212 RCL "X"
213 RTN

// ========= rotary fixing ==========
214 LBL 05
215 R↓
216 LBL 06
217 R↓
218 LBL 07
219 R↓
220 RTN

// ========= T management ==========
// ========= repair global T ==========
221 LBL "RCLT"
222 RCL "T"
223 R↓
224 RTN

// ========= store local T (U) ==========
// needs a LSTO "U" in the outer context
// so that "U" remains local
225 LBL "STOT"
226 R↑
227 STO "U"
228 R↓
229 RTN

// ========= repair local T (U) ==========
230 LBL "LRCLT"
231 RCL "U"
232 R↓
233 RTN

// ========= restore registers and last X ==========
// restore registers called by XIT0-XIT4.
234 LBL 00
235 RCL "R"
236 STO "REGS"
237 R↓
// restore last X
238 RCL "L"
239 STO ST L
240 R↓
241 RTN

// ========= drop one return value ==========
// T->Z->Y->X->L
// local context
242 LBL "DRPX"
243 LSTO "U"
244 XEQ "STOT"
245 RCL "X"
246 STO "L"
247 R↓
248 RCL "Y"
249 STO "X"
250 R↓
251 RCL "Z"
252 STO "Y"
253 R↓
254 RCL "T"
255 STO "Z"
256 R↓
257 GTO "LRCLT"

// ========= drop two return values ==========
258 LBL "DRPXY"
259 XEQ "DRPX"
260 GTO "DRPX"

// ========= temporary register switching ==========
// imoprt local copy of registers to S
261 LBL "IMPRG"
262 XEQ "EXREG"
263 GTO "EXREG"

// this is it's own inverse, if used twice by the above S
// is initialized with a local copy of REGS
// use this to export registers from function
264 LBL "EXREG"
265 XEQ "STOT"
266 RCL "R"
267 STO "S"
268 R↓
269 RCL "REGS"
270 STO "R"
271 R↓
272 XEQ "LRCLT"
// ========= export registers from S ==========
273 LBL "EXPRG"
274 XEQ "STOT"
275 RCL "S"
276 STO "REGS"
277 R↓
278 GTO "LRCLT"

// ========= utility functions ==========
// ========= test shift was last key ==========
279 LBL "SFT?"
280 FS? 64
281 RTNYES
282 RTNNO

// ========= programatic integration template ==========
// subtract the integral MVAR in integrals
// this makes setting it to zero integrates
// and using a program in solve then also works
// MVAR "∫"
// ..
// RCL- "∫"
// RTN
// PGMINT ""
// STO knowns
// STO "LLIM"
// STO "ULIM"
//? STO "ACC"
// INTEG ""

// ========= programatic solve template ==========
// PGMSLV ""
// STO knowns
// SOLVE ""
